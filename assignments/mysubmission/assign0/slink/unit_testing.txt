Intuitively, one can view a unit as the smallest testable part of an 
application. In procedural programming, a unit could be an entire module, but 
it is more commonly an individual function or procedure. In object-oriented 
programming, a unit is often an entire interface, such as a class, but could be 
an individual 
method.

Ideally, each test case is independent from the others. Substitutes such as method 
stubs, mock objects, fakes, and test harnesses can be used to assist testing a 
module in isolation. Unit tests are typically written and run by software 
developers to ensure that code meets its design and behaves as 
intended.

Because some classes may have references to other classes, testing a class can 
frequently spill over into testing another class. A common example of this is 
classes that depend on a database: in order to test the class, the tester often 
writes code that interacts with the database. This is a mistake, because a unit 
test should usually not go outside of its own class boundary, and especially 
should not cross such process/network boundaries because this can introduce 
unacceptable performance problems to the unit test-suite. Crossing such unit 
boundaries turns unit tests into integration tests, and when test cases fail, 
makes it less clear which component is causing the failure. Instead, the 
software developer should create an abstract interface around the database 
queries, and then implement that interface with their own mock object. By 
abstracting this necessary attachment from the code (temporarily reducing the 
net effective coupling), the independent unit can be more thoroughly tested 
than may have been previously achieved. This results in a higher-quality unit 
that is also more 
maintainable.

Techniques

Unit testing is commonly automated, but may still be performed manually. The 
IEEE does not favor one over the other. The objective in unit testing is to 
isolate a unit and validate its correctness. A manual approach to unit testing 
may employ a step-by-step instructional document. However, automation is 
efficient for achieving this, and enables the many benefits listed in this 
article. Conversely, if not planned carefully, a careless manual unit test case 
may execute as an integration test case that involves many software components, 
and thus preclude the achievement of most if not all of the goals established 
for unit testing.

To fully realize the effect of isolation while using an automated approach, the 
unit or code body under test is executed within a framework outside of its 
natural environment. In other words, it is executed outside of the product or 
calling context for which it was originally created. Testing in such an 
isolated manner reveals unnecessary dependencies between the code being tested 
and other units or data spaces in the product. These dependencies can then be 
eliminated.

Using an automation framework, the developer codes criteria, or an oracle or 
result that is known to be good, into the test to verify the unit's 
correctness. During test case execution, the framework logs tests that fail any 
criterion. Many frameworks will also automatically flag these failed test cases 
and report them in a summary. Depending upon the severity of a failure, the 
framework may halt subsequent testing. 
 

As a consequence, unit testing is traditionally a motivator for programmers to 
create decoupled and cohesive code bodies. This practice promotes healthy 
habits in software development. Design patterns, unit testing, and refactoring 
often work together so that the best solution may 
emerge.

Parameterized unit testing

Parameterized unit tests (PUTs) are tests that take parameters. Unlike 
traditional unit tests, which are usually closed methods, PUTs take any set of 
parameters. PUTs have been supported by TestNG, JUnit and various .NET test 
frameworks. Suitable parameters for the unit tests may be supplied manually or 
in some cases are automatically generated by the test framework. Testing tools 
like QuickCheck exist to generate test inputs for PUTs.

Advantages
The goal of unit testing is to isolate each part of the program and show that 
the individual parts are correct. A unit test provides a strict, written 
contract that the piece of code must satisfy. As a result, it affords several 
benefits.

Find problems early
Unit testing finds problems early in the development cycle. This includes both 
bugs in the programmer's implementation and flaws or missing parts of the 
specification for the unit. The 
process of writing a thorough set of tests forces the author to think through 
inputs, outputs, and error conditions, and thus more crisply define the unit's 
desired behavior. The cost of finding a bug before coding begins or when the 
code is first written is considerably lower than the cost of detecting, 
identifying, and correcting the bug later; bugs may also cause problems for the 
end-users of the software. argue that code is impossible or difficult to test 
if poorly written, thus unit testing can force developers to structure 
functions and objects in better 
ways.

In test-driven development (TDD), which is frequently used in both extreme 
programming and scrum, unit tests are created before the code itself is 
written. When the tests pass, that code is 
considered complete. The same unit tests are run against that function 
frequently as the larger code base is developed either as the code is changed 
or via an automated process with the build. If the unit tests fail, it is 
considered to be a bug either in the changed code or the tests themselves. The 
unit tests then allow the location of the fault or failure to be easily traced. 
Since the unit tests alert the development team of the problem before handing 
the code off to testers or clients, it is still early in the development 
process.

Facilitates change
Unit testing allows the programmer to refactor code or upgrade system libraries 
at a later date, and make sure the module still works correctly (e.g., in 
regression testing). The procedure is 
to write test cases for all functions and methods so that whenever a change 
causes a fault, it can be quickly identified. Unit tests detect changes which 
may break a design contract.

Simplifies integration
Unit testing may reduce uncertainty in the units themselves and can be used in 
a bottom-up testing style approach. By testing the parts of a program first and 
then testing the sum of its parts, integration testing becomes much easier.

Documentation
Unit testing provides a sort of living documentation of the system. Developers 
looking to learn what functionality is provided by a unit, and how to use it, 
can look at the unit tests to gain a 
basic understanding of the unit's interface 
(API).

Unit test cases embody characteristics that are critical to the success of the 
unit. These characteristics can indicate appropriate/inappropriate use of a 
unit as well as negative behaviors 
that are to be trapped by the unit. A unit test case, in and of itself, 
documents these critical characteristics, although many software development 
environments do not rely solely upon code to document the product in 
development.

Design
When software is developed using a test-driven approach, the combination of writing the 
unit test to specify the interface plus the refactoring activities performed 
after the test is passing, 
may take the place of formal design. Each unit test can be seen as a design 
element specifying classes, methods, and observable behaviour. The following 
Java example will help illustrate this 
point.

Disadvantages
Decision problem
Testing will not catch every error in the program, because it cannot evaluate 
every execution path in any but the most trivial 
programs. This problem is a superset of the halting problem, 
which is undecidable. The same is true for unit testing. Additionally, unit 
testing by definition only tests the functionality of the units themselves. 
Therefore, it will not catch integration errors or broader system-level errors 
Your next location is: unixhunt/air/macaroni
(such as functions performed across multiple units, or non-functional test 
areas such as performance). Unit testing should be done in conjunction with 
other software testing activities, as they can only show the presence or 
absence of particular errors; they cannot prove a complete absence of errors. 
To guarantee correct behavior for every execution path and every possible 
input, and ensure the absence of errors, other techniques are required, namely 
the application of formal methods to proving that a software component has no 
unexpected behavior.

Not integration testing
An elaborate hierarchy of unit tests does not equal integration testing. 
Integration with peripheral units should be included in integration tests, but not in unit tests.
Combinatorial problem
Software testing is a combinatorial problem. For example, every Boolean 
decision statement requires at least two tests: one with an outcome of "true" 
and one with an outcome of "false". As a result, for every line of code 
written, programmers often need 3 to 5 lines of test code. Meaning, if two 
chronometers contradict, how do you know which one is correct?

Realism
Another challenge related to writing the unit tests is the difficulty of setting up 
realistic and useful tests. It is necessary to create relevant initial 
conditions so the part of the application being tested behaves like part of the 
complete system. If these initial conditions are not set correctly, the test 
will not be exercising the code in a realistic context, which diminishes the 
value and accuracy of unit test results.

Record keeping
To obtain the intended benefits from unit testing, rigorous discipline is 
needed throughout the software development process. It is essential to keep 
careful records not only of the tests that have been performed, but also of all 
changes that have been made to the source code of this or any other unit in the 
software. Use of a version control system is essential. If a later version of 
the unit fails a particular test that it had previously passed, the 
version-control software can provide a list of the source code changes (if any) 
that have been applied to the unit since that time.

Sustainability challenges
It is also essential to implement a sustainable process for ensuring that test 
case failures are reviewed regularly and addressed immediately. If such a 
process is not implemented and ingrained into the team's workflow, the 
application will evolve out of sync with the unit test suite, increasing false 
positives and reducing the effectiveness of the test 
suite.

Platform differences
Unit testing embedded system software presents a unique challenge: Because the 
software is being developed on a different platform than the one it will 
eventually run on, you cannot readily run a test program in the actual 
deployment environment, as is possible with desktop programs.

excerpt from https://en.wikipedia.org/wiki/Unit_testing
